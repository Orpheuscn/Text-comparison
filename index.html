<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparaison et Édition de Textes (Highlight Manuel Rouge/Vert)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <style>
        /* --- Original styles --- */
        body {
            font-family: 'Baskerville', 'Palatino Linotype', 'Book Antiqua', serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f9f7f1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 20px;
        }

        h1 {
            font-size: 28px;
            color: #4a4a4a;
            margin-bottom: 10px;
        }

        .subtitle {
            font-style: italic;
            color: #666;
            margin-bottom: 20px;
        }

        .input-area {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .input-area .textarea-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .input-area label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #4a4a4a;
        }

        /* **** 修改点：为 textarea 添加 dir="auto" (通过 CSS 设置，更灵活) **** */
        .input-area textarea {
            flex-grow: 1;
            min-height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            box-sizing: border-box;
            width: 100%;
            direction: auto;
            /* CSS 方式设置方向自适应 */
            text-align: start;
            /* 文本对齐方式跟随书写方向 */
        }

        .text-comparison {
            display: flex;
            gap: 0;
            position: relative;
        }

        /* **** 修改点：为文本列添加 dir="auto" **** */
        .text-column {
            flex: 1;
            padding: 20px;
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            z-index: 1;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
            direction: auto;
            /* CSS 方式设置方向自适应 */
            text-align: start;
            /* 文本对齐方式跟随书写方向 */
        }

        .column-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            text-align: center;
        }

        p {
            margin-bottom: 15px;
        }

        .highlight-add {
            background-color: #e6ffe6;
            color: #006600;
            border-radius: 3px;
            padding: 0 2px;
            text-decoration: none;
            /* Ensure no accidental underline */
        }

        .highlight-remove {
            background-color: #ffe6e6;
            text-decoration: line-through;
            color: #cc0000;
            border-radius: 3px;
            padding: 0 2px;
        }

        .paragraph-number {
            font-size: 12px;
            color: #999;
            margin-right: 5px;
            user-select: none;
            display: inline-block;
            width: 25px;
            text-align: right;
            vertical-align: top;
            padding-right: 5px;
        }

        /* **** 修改点：确保段落内容也使用 start 对齐 **** */
        .paragraph-content {
            display: inline;
            text-align: start;
            /* 原为 justify */
        }

        .legend {
            margin-top: 30px;
            padding: 15px;
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }

        .legend-item {
            display: inline-block;
            margin-right: 20px;
        }

        .controls {
            margin-bottom: 20px;
            text-align: center;
        }

        button {
            background-color: #4a4a4a;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }

        button:hover {
            background-color: #333;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .notes {
            margin-top: 30px;
            font-size: 14px;
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-style: italic;
            color: #999;
        }

        .ruler-column {
            width: 20px;
            background-color: #f0f0f0;
            position: relative;
            border-top: 1px solid #e0e0e0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            z-index: 0;
        }

        .ruler-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #ddd;
        }

        .ruler-section {
            height: 100%;
            border-bottom: 1px dotted #ccc;
            box-sizing: border-box;
        }

        .text-column p {
            position: relative;
            margin-bottom: 15px;
            padding: 0;
            line-height: 1.6;
        }

        .text-column.editing-active {
            outline: 2px solid #4a90e2;
            background-color: #f8faff;
        }

        @media (max-width: 768px) {
            .input-area {
                flex-direction: column;
            }
            .text-comparison {
                flex-direction: column;
            }
            .ruler-column {
                display: none;
            }
        }
        /* --- End Original styles --- */

        /* --- Styles for Popup --- */
        #highlight-popup {
            position: absolute;
            background-color: #555;
            color: white;
            border-radius: 4px;
            padding: 5px 8px;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        #highlight-popup button {
            background-color: #777;
            color: white;
            border: none;
            padding: 3px 8px;
            margin-left: 5px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }

        #highlight-popup button:hover {
            background-color: #999;
        }
        /* --- NO Style for <mark> needed --- */

    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Analyse Comparative et Édition de Textes</h1>
            <div class="subtitle">Les Statues Meurent Aussi (Input Direct & Édition)</div>
        </header>

        <div class="input-area">
            <div class="textarea-container">
                <label for="inputText1">Texte Source 1 :</label>
                <textarea id="inputText1" placeholder="Collez le premier texte ici..." dir="auto"></textarea>
            </div>
            <div class="textarea-container">
                <label for="inputText2">Texte Source 2 :</label>
                <textarea id="inputText2" placeholder="Collez le deuxième texte ici..." dir="auto"></textarea>
            </div>
        </div>

        <div class="controls">
            <button id="showDifferences">Comparer / Rafraîchir</button>
            <button id="showOriginal">Texte 2 uniquement</button>
            <button id="showBoth">Afficher les deux versions</button>
            <hr style="margin: 15px 0; border: 0; border-top: 1px solid #eee;">
            <button id="editTexts">Éditer les textes affichés</button>
            <button id="saveChanges" disabled>Sauvegarder les modifications</button>
        </div>

        <div id="content" dir="auto">
            <div class="loading">Collez les textes ci-dessus et cliquez sur "Comparer / Rafraîchir".</div>
        </div>

        <div class="legend">
            <span class="legend-item"><span class="highlight-add">Texte ajouté/surligné (droite)</span></span>
            <span class="legend-item"><span class="highlight-remove">Texte supprimé/surligné (gauche)</span></span>
            <span class="legend-item">Texte inchangé</span>
        </div>

        <div class="notes">
            <p><strong>Note :</strong> Sélectionnez du texte dans les colonnes pour le surligner (rouge à gauche, vert à droite) ou annuler le surlignage.</p>
        </div>
    </div>

    <div id="highlight-popup">
        <button id="popup-highlight-btn">Surligner</button>
        <button id="popup-remove-highlight-btn">Annuler</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Global variables
            let source1Data = { titre: "Source 1", texte: [] };
            let source2Data = { titre: "Source 2", texte: [] };
            let isEditing = false;
            const dmp = new diff_match_patch();
            let currentRange = null;

            // Element references
            const inputText1Elem = document.getElementById('inputText1');
            const inputText2Elem = document.getElementById('inputText2');
            const contentDiv = document.getElementById('content');
            const showDifferencesBtn = document.getElementById('showDifferences');
            const showOriginalBtn = document.getElementById('showOriginal');
            const showBothBtn = document.getElementById('showBoth');
            const editTextsBtn = document.getElementById('editTexts');
            const saveChangesBtn = document.getElementById('saveChanges');
            const textDisplayArea = document.getElementById('content'); // Used for mouseup listener
            const popup = document.getElementById('highlight-popup');
            const highlightBtn = document.getElementById('popup-highlight-btn');
            const removeHighlightBtn = document.getElementById('popup-remove-highlight-btn');

            // --- Core Functions ---

            function setEditingState(editing) {
                isEditing = editing;
                const text1Div = document.getElementById('text1');
                const text2Div = document.getElementById('text2');

                if (text1Div) {
                    text1Div.contentEditable = editing;
                    text1Div.classList.toggle('editing-active', editing);
                }
                if (text2Div) {
                    text2Div.contentEditable = editing;
                    text2Div.classList.toggle('editing-active', editing);
                }

                showDifferencesBtn.disabled = editing;
                showOriginalBtn.disabled = editing;
                showBothBtn.disabled = editing;
                editTextsBtn.disabled = editing; // Disable edit button when editing
                saveChangesBtn.disabled = !editing; // Enable save button when editing

                const ruler = document.getElementById('rulerColumn');
                if (ruler) {
                    ruler.style.display = editing ? 'none' : ((window.innerWidth > 768) ? 'flex' : 'none');
                }
                hidePopup(); // Hide popup when changing state
            }

            function findDifferences(text1, text2) {
                const t1 = String(text1 || '');
                const t2 = String(text2 || '');
                const diffs_dmp = dmp.diff_main(t1, t2);
                dmp.diff_cleanupSemantic(diffs_dmp);
                const result = diffs_dmp.map(part => {
                    let type;
                    if (part[0] === 1) type = 'add';
                    else if (part[0] === -1) type = 'remove';
                    else type = 'same';
                    return { type: type, text: part[1] };
                });
                return result.filter(d => d.text && d.text.length > 0); // Filter out empty parts
            }

            function createRuler() {
                if (isEditing) return; // Don't show ruler while editing

                const rulerColumn = document.getElementById('rulerColumn');
                const leftColumn = document.getElementById('text1');
                const rightColumn = document.getElementById('text2');

                if (!rulerColumn || !leftColumn || !rightColumn) return;

                // Hide ruler on small screens
                if (window.innerWidth <= 768) {
                    rulerColumn.style.display = 'none';
                    return;
                } else {
                    rulerColumn.style.display = 'flex';
                }

                rulerColumn.innerHTML = ''; // Clear previous ruler lines
                const leftParagraphs = leftColumn.querySelectorAll('p');
                const rightParagraphs = rightColumn.querySelectorAll('p');

                if (leftParagraphs.length === 0 && rightParagraphs.length === 0) return;

                const paragraphCount = Math.max(leftParagraphs.length, rightParagraphs.length);

                for (let i = 0; i < paragraphCount; i++) {
                    const rulerSection = document.createElement('div');
                    rulerSection.className = 'ruler-section';

                    const leftPara = i < leftParagraphs.length ? leftParagraphs[i] : null;
                    const rightPara = i < rightParagraphs.length ? rightParagraphs[i] : null;

                    // Get actual height after rendering
                    const leftHeight = leftPara ? leftPara.offsetHeight : 0;
                    const rightHeight = rightPara ? rightPara.offsetHeight : 0;
                    const maxHeight = Math.max(leftHeight, rightHeight, 20); // Ensure minimum height

                    rulerSection.style.height = `${maxHeight}px`;
                    rulerColumn.appendChild(rulerSection);

                    // Force paragraphs to match ruler height
                    if (leftPara) leftPara.style.minHeight = `${maxHeight}px`;
                    if (rightPara) rightPara.style.minHeight = `${maxHeight}px`;
                }
            }

            // **** 修改点：在生成 HTML 时为 #text1 和 #text2 添加 dir="auto" ****
            function processTexts(data1, data2) {
                const text1Array = data1.texte || [];
                const text2Array = data2.texte || [];

                // Generate HTML with dir="auto" for text containers
                contentDiv.innerHTML = `
                    <div class="text-comparison" id="textComparison">
                        <div class="text-column" id="textColumn1">
                            <div class="column-header">${data1.titre || 'Source 1'}</div>
                            <div id="text1" dir="auto">
                                ${text1Array.map((para, index) => `
                                    <p data-para-index="${index}">
                                        <span class="paragraph-number">${index + 1}</span>
                                        <span class="paragraph-content">${(para || '').replace(/</g, "&lt;").replace(/>/g, "&gt;") || '&nbsp;'}</span>
                                    </p>`).join('')}
                            </div>
                        </div>
                        <div class="ruler-column" id="rulerColumn"></div>
                        <div class="text-column" id="textColumn2">
                            <div class="column-header">${data2.titre || 'Source 2'}</div>
                            <div id="text2" dir="auto">
                                ${text2Array.map((para, index) => `
                                    <p data-para-index="${index}">
                                        <span class="paragraph-number">${index + 1}</span>
                                        <span class="paragraph-content">${(para || '').replace(/</g, "&lt;").replace(/>/g, "&gt;") || '&nbsp;'}</span>
                                    </p>`).join('')}
                            </div>
                        </div>
                    </div>`;
                // Call createRuler after a short delay to allow rendering
                setTimeout(createRuler, 0);
            }

            function displayDifferences(text1Array, text2Array) {
                if (isEditing) return;

                const text1Div = document.getElementById('text1');
                const text2Div = document.getElementById('text2');
                if (!text1Div || !text2Div) return;

                // Ensure parent containers have dir="auto"
                text1Div.setAttribute('dir', 'auto');
                text2Div.setAttribute('dir', 'auto');

                const maxLen = Math.max(text1Array.length, text2Array.length);
                let text1HTMLContent = '';
                let text2HTMLContent = '';

                for (let i = 0; i < maxLen; i++) {
                    const para1 = text1Array[i] || "";
                    const para2 = text2Array[i] || "";
                    const diffs = findDifferences(para1, para2);
                    let para1HTML = '';
                    let para2HTML = '';

                    diffs.forEach(diff => {
                        const safeText = (diff.text || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        if (diff.type === 'same') {
                            para1HTML += safeText;
                            para2HTML += safeText;
                        } else if (diff.type === 'add') {
                            para2HTML += `<span class="highlight-add">${safeText}</span>`;
                        } else if (diff.type === 'remove') {
                            para1HTML += `<span class="highlight-remove">${safeText}</span>`;
                        }
                    });

                    // Paragraph <p> inherits dir="auto" from parent div
                    text1HTMLContent += `
                        <p data-para-index="${i}">
                            <span class="paragraph-number">${i + 1}</span>
                            <span class="paragraph-content">${para1HTML || '&nbsp;'}</span>
                        </p>`;
                    text2HTMLContent += `
                        <p data-para-index="${i}">
                            <span class="paragraph-number">${i + 1}</span>
                            <span class="paragraph-content">${para2HTML || '&nbsp;'}</span>
                        </p>`;
                }
                text1Div.innerHTML = text1HTMLContent;
                text2Div.innerHTML = text2HTMLContent;

                // Ensure layout is correct
                const textComparison = document.querySelector('#textComparison');
                if (textComparison) {
                    textComparison.style.flexDirection = 'row'; // Ensure side-by-side
                }
                const col1 = document.getElementById('textColumn1');
                const col2 = document.getElementById('textColumn2');
                const ruler = document.getElementById('rulerColumn');
                if (col1) col1.style.display = 'block';
                if (col2) col2.style.display = 'block';
                if (ruler) ruler.style.display = (window.innerWidth > 768 && !isEditing) ? 'flex' : 'none';

                setTimeout(createRuler, 0); // Recalculate ruler
            }

            // **** 修改点：确保 showOriginalOnly 和 showBothVersions 中也设置 dir="auto" ****
            function showOriginalOnly() {
                if (isEditing) return;
                if (source2Data.texte.length === 0 && source1Data.texte.length === 0) return;

                const textComparison = document.querySelector('#textComparison');
                if (!textComparison) return;

                const col1 = document.getElementById('textColumn1');
                const ruler = document.getElementById('rulerColumn');
                const col2 = document.getElementById('textColumn2');
                const text1Div = document.getElementById('text1');
                const text2Div = document.getElementById('text2');

                if (col1) col1.style.display = 'none';
                if (ruler) ruler.style.display = 'none';
                if (text1Div) text1Div.innerHTML = '';

                if (col2 && text2Div) {
                    col2.style.display = 'block';
                    col2.querySelector('.column-header').innerText = source2Data.titre || 'Source 2';
                    text2Div.setAttribute('dir', 'auto'); // Ensure dir="auto" is set
                    text2Div.innerHTML = source2Data.texte.map((para, index) => `
                        <p data-para-index="${index}">
                            <span class="paragraph-number">${index + 1}</span>
                            <span class="paragraph-content">${(para || '').replace(/</g, "&lt;").replace(/>/g, "&gt;") || '&nbsp;'}</span>
                        </p>`).join('');
                } else if (contentDiv) {
                    contentDiv.innerHTML = '<div class="loading">Erreur: Impossible d\'afficher le Texte 2.</div>';
                }
                hidePopup();
            }

            function showBothVersions() {
                if (isEditing) return;
                if (source1Data.texte.length === 0 && source2Data.texte.length === 0) return;

                // processTexts handles setting dir="auto" and rendering both texts
                processTexts(source1Data, source2Data);

                // Ensure layout is correct (redundant if processTexts does it, but safe)
                const textComparison = document.querySelector('#textComparison');
                if (textComparison) textComparison.style.flexDirection = 'row';
                const col1 = document.getElementById('textColumn1');
                const col2 = document.getElementById('textColumn2');
                const ruler = document.getElementById('rulerColumn');
                if (col1) col1.style.display = 'block';
                if (col2) col2.style.display = 'block';
                if (ruler) ruler.style.display = (window.innerWidth > 768 && !isEditing) ? 'flex' : 'none';

                setTimeout(createRuler, 0); // Recalculate ruler
                hidePopup();
            }
            // --- End Core Functions ---


            // **** START: Manual Highlighting Logic (No changes needed here for RTL/LTR) ****

            function showPopup(x, y, range) {
                if (isEditing) return;
                currentRange = range;
                popup.style.left = `${x}px`;
                popup.style.top = `${y}px`;
                popup.style.display = 'block';
            }

            function hidePopup() {
                popup.style.display = 'none';
                currentRange = null;
            }

            textDisplayArea.addEventListener('mouseup', (event) => {
                if (isEditing) return;
                const selection = window.getSelection();
                const text1Div = document.getElementById('text1');
                const text2Div = document.getElementById('text2');

                if (selection && !selection.isCollapsed && selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const commonAncestor = range.commonAncestorContainer;

                    // Check if selection is fully within one of the target divs
                    let isInTarget = false;
                    if (text1Div && (text1Div.contains(commonAncestor) || commonAncestor === text1Div)) isInTarget = true;
                    else if (text2Div && (text2Div.contains(commonAncestor) || commonAncestor === text2Div)) isInTarget = true;

                    // More robust check if commonAncestor is high level
                    if (!isInTarget) {
                         if (text1Div && text1Div.contains(range.startContainer) && text1Div.contains(range.endContainer)) isInTarget = true;
                         if (!isInTarget && text2Div && text2Div.contains(range.startContainer) && text2Div.contains(range.endContainer)) isInTarget = true;
                    }


                    if (isInTarget) {
                        const rect = range.getBoundingClientRect();
                        // Position popup slightly above the selection
                        showPopup(rect.left + window.scrollX, rect.top + window.scrollY - popup.offsetHeight - 5, range);
                    } else {
                        hidePopup(); // Selection is outside target areas
                    }
                } else {
                    // If click is outside popup while it's visible, hide it
                    if (!popup.contains(event.target)) {
                        hidePopup();
                    }
                }
            });

            // Hide popup if user clicks elsewhere while it's open
            document.addEventListener('mousedown', (event) => {
                if (!popup.contains(event.target) && popup.style.display === 'block') {
                     // Also check if selection was cleared by this mousedown
                     const selection = window.getSelection();
                     if (selection.isCollapsed || !selection.rangeCount > 0) {
                          hidePopup();
                     }
                }
            });

            // Helper function to unwrap a node (remove the node, keep its children)
            function unwrapNode(node) {
                const parent = node.parentNode;
                if (!parent) return;
                // Move all children out before removing the node
                while (node.firstChild) {
                    parent.insertBefore(node.firstChild, node);
                }
                parent.removeChild(node);
            }

            // Helper function to find all highlight spans intersecting a range
            function findIntersectingHighlightSpans(range) {
                const spans = [];
                const commonAncestor = range.commonAncestorContainer;

                // Iterate through nodes within the common ancestor
                const nodeIterator = document.createNodeIterator(
                    commonAncestor,
                    NodeFilter.SHOW_ELEMENT, // Only consider element nodes
                    (node) => {
                        // Filter: Accept only highlight spans that intersect the range
                        if (node.nodeName === 'SPAN' &&
                           (node.classList.contains('highlight-add') || node.classList.contains('highlight-remove')) &&
                           range.intersectsNode(node)) {
                            return NodeFilter.FILTER_ACCEPT;
                        }
                        return NodeFilter.FILTER_REJECT;
                    }
                );

                let currentNode;
                while (currentNode = nodeIterator.nextNode()) {
                    spans.push(currentNode);
                }

                 // Sometimes the range might be *inside* a highlight span. Check parents.
                 for (const container of [range.startContainer, range.endContainer]) {
                    if (container && container.parentNode && container.parentNode.nodeName === 'SPAN' &&
                       (container.parentNode.classList.contains('highlight-add') || container.parentNode.classList.contains('highlight-remove')) &&
                       !spans.includes(container.parentNode)) // Avoid duplicates
                    {
                         // Double check intersection as parent might be larger than range
                        if (range.intersectsNode(container.parentNode)) {
                             spans.push(container.parentNode);
                        }
                    }
                 }

                return [...new Set(spans)]; // Return unique spans found
            }

            // --- Revised Remove Highlight Button ---
            removeHighlightBtn.addEventListener('click', () => {
                if (!currentRange) { hidePopup(); return; } // Need a valid range

                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0) { hidePopup(); return; }
                const range = selection.getRangeAt(0); // Use the current selection range

                try {
                    const spansToUnwrap = findIntersectingHighlightSpans(range);
                    console.log("Annuler: Spans to unwrap:", spansToUnwrap);

                    if (spansToUnwrap.length > 0) {
                         // Iterate backwards because unwrapping modifies the DOM and affects subsequent node references
                         for (let i = spansToUnwrap.length - 1; i >= 0; i--) {
                            unwrapNode(spansToUnwrap[i]);
                         }
                         // Normalize the parent to merge adjacent text nodes created by unwrapping
                         const commonAncestor = range.commonAncestorContainer;
                          // Check if commonAncestor is a valid node and has normalize method
                         if (commonAncestor && commonAncestor.normalize) {
                             try {
                                 commonAncestor.normalize();
                             } catch(normError) {
                                 console.warn("Could not normalize common ancestor:", normError);
                                 // Try normalizing parent if ancestor was text node
                                 if (commonAncestor.parentNode && commonAncestor.parentNode.normalize) {
                                      commonAncestor.parentNode.normalize();
                                 }
                             }
                         }
                         console.log("Annuler: Unwrapping complete.");
                    } else {
                         console.log("Annuler: No highlight spans found in selection.");
                    }

                } catch (e) {
                    console.error("Erreur lors de la suppression du surlignage:", e);
                } finally {
                     selection.removeAllRanges(); // Deselect text
                     hidePopup();
                }
            });


            // --- Revised Highlight Button ---
            highlightBtn.addEventListener('click', () => {
                if (!currentRange) { hidePopup(); return; } // Need a valid range

                const selection = window.getSelection();
                 if (!selection || selection.isCollapsed || selection.rangeCount === 0) { hidePopup(); return; }
                const range = selection.getRangeAt(0); // Use current selection range
                const selectedText = range.toString();
                if (selectedText.trim().length === 0) { hidePopup(); return; } // Don't highlight only whitespace

                // 1. Determine target column and highlight class
                let highlightClass = '';
                const text1Div = document.getElementById('text1');
                const text2Div = document.getElementById('text2');
                let checkNode = range.commonAncestorContainer;
                if(checkNode.nodeType === Node.TEXT_NODE) { checkNode = checkNode.parentNode; } // Go up if starting inside text

                if (text1Div && text1Div.contains(checkNode)) {
                    highlightClass = 'highlight-remove'; // Red for left column
                } else if (text2Div && text2Div.contains(checkNode)) {
                    highlightClass = 'highlight-add';    // Green for right column
                } else {
                     // Fallback check based on start container
                     let startCheckNode = range.startContainer;
                      if(startCheckNode.nodeType === Node.TEXT_NODE) { startCheckNode = startCheckNode.parentNode; }
                      if (text1Div && text1Div.contains(startCheckNode)) { highlightClass = 'highlight-remove'; }
                      else if (text2Div && text2Div.contains(startCheckNode)) { highlightClass = 'highlight-add'; }
                }

                if (!highlightClass) { console.error("Could not determine target column for highlighting."); hidePopup(); return; }

                try {
                    // --- Step 1: Remove ANY existing highlights within the current selection first ---
                    const spansToUnwrap = findIntersectingHighlightSpans(range);
                    console.log("Surligner (Step 1): Spans to unwrap before applying new highlight:", spansToUnwrap);

                     // Store selection boundaries *before* potentially modifying the DOM
                     const savedStartContainer = range.startContainer;
                     const savedStartOffset = range.startOffset;
                     const savedEndContainer = range.endContainer;
                     const savedEndOffset = range.endOffset;
                     let selectionRestored = false;

                     if (spansToUnwrap.length > 0) {
                         for (let i = spansToUnwrap.length - 1; i >= 0; i--) {
                            unwrapNode(spansToUnwrap[i]);
                         }
                          // Try to restore the selection accurately after unwrapping nodes
                         selection.removeAllRanges();
                          const newRange = document.createRange();
                          try {
                               // Check if containers still exist before setting range
                               if (document.contains(savedStartContainer) && document.contains(savedEndContainer)) {
                                    newRange.setStart(savedStartContainer, savedStartOffset);
                                    newRange.setEnd(savedEndContainer, savedEndOffset);
                                    selection.addRange(newRange);
                                    currentRange = newRange; // Update the global currentRange
                                    selectionRestored = true;
                                    console.log("Surligner (Step 1): Selection restored after unwrapping.");
                               } else {
                                   console.warn("Surligner (Step 1): Start or end container no longer exists after unwrapping.");
                               }
                          } catch (restoreError) {
                               console.warn("Surligner (Step 1): Could not fully restore selection after unwrapping.", restoreError);
                          }
                     } else {
                        console.log("Surligner (Step 1): No existing highlights to remove.");
                        selectionRestored = true; // No unwrapping happened, selection is still valid
                     }

                     // Only proceed if selection seems valid
                     if (!selectionRestored || selection.isCollapsed || selection.rangeCount === 0) {
                          console.warn("Surligner (Step 2): Aborting highlight because selection was lost or became invalid.");
                          hidePopup();
                          return;
                     }

                     const rangeToWrap = selection.getRangeAt(0); // Get the potentially restored range

                    // --- Step 2: Apply the new highlight span ---
                    console.log("Surligner (Step 2): Attempting to wrap selection with class:", highlightClass);
                    const span = document.createElement('span');
                    span.className = highlightClass;

                    try {
                        // surroundContents is preferred as it preserves structure
                        rangeToWrap.surroundContents(span);
                        console.log("Surligner (Step 2): surroundContents successful.");
                         // Normalize parent after wrapping to merge adjacent text nodes if needed
                         if (span.parentNode && span.parentNode.normalize) {
                             span.parentNode.normalize();
                         }
                    } catch (e) {
                         // surroundContents fails if the range spans across block elements or has complex structure
                        console.warn("Surligner (Step 2): surroundContents failed, attempting fragment extraction.", e);
                         try {
                              // Extract content, wrap it, then insert
                              const fragment = rangeToWrap.extractContents();
                              span.appendChild(fragment);
                              rangeToWrap.insertNode(span);
                              console.log("Surligner (Step 2): Fragment extraction and wrapping successful.");
                               if (span.parentNode && span.parentNode.normalize) {
                                    span.parentNode.normalize();
                               }
                         } catch (extractError) {
                              console.error("Surligner (Step 2): Fragment extraction also failed:", extractError);
                              alert("Le surlignage a échoué. Essayez de sélectionner un segment de texte plus simple.");
                         }
                    }

                } catch (error) {
                    console.error("Erreur lors de la tentative de surlignage:", error);
                } finally {
                    selection.removeAllRanges(); // Deselect text
                    hidePopup();
                }
            });

            // **** END: Manual Highlighting Logic ****


            // --- Event Listeners ---
            showDifferencesBtn.addEventListener('click', function() {
                if (isEditing) return;
                const text1Input = inputText1Elem.value;
                const text2Input = inputText2Elem.value;
                // Replace non-breaking spaces which can interfere with diffing
                const cleanedText1 = text1Input.replace(/\u00A0/g, ' ');
                const cleanedText2 = text2Input.replace(/\u00A0/g, ' ');
                const text1Array = cleanedText1.split('\n');
                const text2Array = cleanedText2.split('\n');
                source1Data = { titre: "Source 1 (Input)", texte: text1Array };
                source2Data = { titre: "Source 2 (Input)", texte: text2Array };

                if (cleanedText1.length === 0 && cleanedText2.length === 0) {
                    contentDiv.innerHTML = '<div class="loading">Veuillez saisir du texte dans au moins une des zones.</div>';
                    return;
                }
                processTexts(source1Data, source2Data); // Render initial structure
                displayDifferences(text1Array, text2Array); // Apply diff highlights
                hidePopup();
            });

            editTextsBtn.addEventListener('click', function() {
                const text1Div = document.getElementById('text1');
                const text2Div = document.getElementById('text2');
                // Check if there's content loaded to edit
                if (!text1Div || !text2Div || (source1Data.texte.length === 0 && source2Data.texte.length === 0)) {
                    alert("Veuillez d'abord comparer les textes pour pouvoir les éditer.");
                    return;
                }
                // Render plain text in divs for editing
                text1Div.innerHTML = source1Data.texte.map(p => `<p>${(p || '').replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>`).join('');
                text2Div.innerHTML = source2Data.texte.map(p => `<p>${(p || '').replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>`).join('');
                setEditingState(true);
            });

            saveChangesBtn.addEventListener('click', function() {
                const text1Div = document.getElementById('text1');
                const text2Div = document.getElementById('text2');
                if (!text1Div || !text2Div) return;

                // Get edited text using innerText to avoid HTML tags
                const editedText1 = text1Div.innerText.trim();
                const editedText2 = text2Div.innerText.trim();
                const newText1Array = editedText1.split('\n');
                const newText2Array = editedText2.split('\n');

                // Update source data and input textareas
                source1Data.texte = newText1Array;
                source2Data.texte = newText2Array;
                inputText1Elem.value = newText1Array.join('\n');
                inputText2Elem.value = newText2Array.join('\n');

                setEditingState(false); // Exit editing mode
                showBothVersions(); // Show the edited versions side-by-side (plain text)
                alert("Modifications sauvegardées ! Les zones de texte initiales ont été mises à jour. Vous pouvez comparer à nouveau si vous le souhaitez.");
            });

            showOriginalBtn.addEventListener('click', showOriginalOnly);
            showBothBtn.addEventListener('click', showBothVersions);

            // Adjust ruler on resize if not editing
            window.addEventListener('resize', () => {
                if (!isEditing) {
                    createRuler();
                } else {
                    const ruler = document.getElementById('rulerColumn');
                    if (ruler) ruler.style.display = 'none';
                }
                hidePopup(); // Hide popup on resize
            });

            // Initialize state
            setEditingState(false);

        }); // End DOMContentLoaded
    </script>
</body>
</html>